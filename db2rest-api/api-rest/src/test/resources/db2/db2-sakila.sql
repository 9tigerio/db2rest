------------------------------------------------------------
-- TABLE: tops
------------------------------------------------------------
CREATE TABLE tops (
    top_item VARCHAR(30) NOT NULL,
    color VARCHAR(30) NOT NULL,
    t_size VARCHAR(2) NOT NULL
);

------------------------------------------------------------
-- TABLE: bottoms
------------------------------------------------------------
CREATE TABLE bottoms (
    bottom_item VARCHAR(30) NOT NULL,
    color VARCHAR(30) NOT NULL,
    b_size VARCHAR(2) NOT NULL
);

------------------------------------------------------------
-- TABLE: users
------------------------------------------------------------
CREATE TABLE users (
    auid INTEGER NOT NULL,
    username VARCHAR(45) NOT NULL,
    password VARCHAR(45) NOT NULL,
    createdate DATE DEFAULT CURRENT DATE,
    is_active CHAR(1) DEFAULT 'Y',
    CONSTRAINT pk_users PRIMARY KEY (auid)
);

------------------------------------------------------------
-- TABLE: userprofile
------------------------------------------------------------
CREATE TABLE userprofile (
    apid INTEGER NOT NULL,
    auid INTEGER NOT NULL,
    firstname VARCHAR(50) NOT NULL,
    lastname VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    phone VARCHAR(45) NOT NULL,
    CONSTRAINT pk_userprofile PRIMARY KEY (apid)
);

------------------------------------------------------------
-- TABLE: actor
------------------------------------------------------------
CREATE TABLE actor (
    actor_id INTEGER NOT NULL,
    first_name VARCHAR(45) NOT NULL,
    last_name VARCHAR(45) NOT NULL,
    last_update TIMESTAMP DEFAULT CURRENT TIMESTAMP,
    CONSTRAINT pk_actor PRIMARY KEY (actor_id)
);

CREATE INDEX idx_actor_last_name ON actor(last_name);

CREATE SEQUENCE actor_sequence
    START WITH 200
    INCREMENT BY 1;

------------------------------------------------------------
-- TABLE: country
------------------------------------------------------------
CREATE TABLE country (
    country_id INTEGER NOT NULL,
    country VARCHAR(50) NOT NULL,
    last_update DATE,
    CONSTRAINT pk_country PRIMARY KEY (country_id)
);

CREATE SEQUENCE country_sequence;

CREATE OR REPLACE TRIGGER country_before_update
BEFORE UPDATE ON country
REFERENCING NEW AS NEW
FOR EACH ROW
BEGIN ATOMIC
    SET NEW.last_update = CURRENT DATE;
END;

------------------------------------------------------------
-- TABLE: person
------------------------------------------------------------
CREATE TABLE person (
    person_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INTEGER
);

------------------------------------------------------------
-- TABLE: city
------------------------------------------------------------
CREATE TABLE city (
    city_id INTEGER NOT NULL,
    city VARCHAR(50) NOT NULL,
    country_id INTEGER NOT NULL,
    last_update DATE NOT NULL,
    CONSTRAINT pk_city PRIMARY KEY (city_id),
    CONSTRAINT fk_city_country FOREIGN KEY (country_id)
        REFERENCES country(country_id)
);

CREATE INDEX idx_fk_country_id ON city(country_id);

CREATE SEQUENCE city_sequence;

CREATE OR REPLACE TRIGGER city_before_insert
BEFORE INSERT ON city
REFERENCING NEW AS NEW
FOR EACH ROW
BEGIN ATOMIC
    IF NEW.city_id IS NULL THEN
        SET NEW.city_id = NEXT VALUE FOR city_sequence;
    END IF;
    SET NEW.last_update = CURRENT DATE;
END;

CREATE OR REPLACE TRIGGER city_before_update
BEFORE UPDATE ON city
REFERENCING NEW AS NEW
FOR EACH ROW
BEGIN ATOMIC
    SET NEW.last_update = CURRENT DATE;
END;

------------------------------------------------------------
-- TABLE: address
------------------------------------------------------------
CREATE TABLE address (
    address_id INTEGER NOT NULL,
    address VARCHAR(50) NOT NULL,
    address2 VARCHAR(50),
    district VARCHAR(20) NOT NULL,
    city_id INTEGER NOT NULL,
    postal_code VARCHAR(10),
    phone VARCHAR(20) NOT NULL,
    last_update DATE NOT NULL,
    CONSTRAINT pk_address PRIMARY KEY (address_id)
);

CREATE INDEX idx_fk_city_id ON address(city_id);

ALTER TABLE address
ADD CONSTRAINT fk_address_city
FOREIGN KEY (city_id) REFERENCES city(city_id);

CREATE SEQUENCE address_sequence;

CREATE OR REPLACE TRIGGER address_before_insert
BEFORE INSERT ON address
REFERENCING NEW AS NEW
FOR EACH ROW
BEGIN ATOMIC
    IF NEW.address_id IS NULL THEN
        SET NEW.address_id = NEXT VALUE FOR address_sequence;
    END IF;
    SET NEW.last_update = CURRENT DATE;
END;

CREATE OR REPLACE TRIGGER address_before_update
BEFORE UPDATE ON address
REFERENCING NEW AS NEW
FOR EACH ROW
BEGIN ATOMIC
    SET NEW.last_update = CURRENT DATE;
END;

------------------------------------------------------------
-- TABLE: language
------------------------------------------------------------
CREATE TABLE language (
    language_id INTEGER NOT NULL,
    name CHAR(20) NOT NULL,
    last_update DATE NOT NULL,
    CONSTRAINT pk_language PRIMARY KEY (language_id)
);

CREATE SEQUENCE language_sequence;

CREATE OR REPLACE TRIGGER language_before_update
BEFORE UPDATE ON language
REFERENCING NEW AS NEW
FOR EACH ROW
BEGIN ATOMIC
    SET NEW.last_update = CURRENT DATE;
END;

------------------------------------------------------------
-- TABLE: director
------------------------------------------------------------
CREATE TABLE director (
    director_id INTEGER NOT NULL,
    first_name VARCHAR(45) NOT NULL,
    last_name VARCHAR(45) NOT NULL,
    last_update DATE DEFAULT CURRENT DATE,
    CONSTRAINT pk_director PRIMARY KEY (director_id)
);

------------------------------------------------------------
-- TABLE: vanity_van
------------------------------------------------------------
CREATE TABLE vanity_van (
    van_id VARCHAR(45) NOT NULL,
    name VARCHAR(45) NOT NULL,
    last_update DATE DEFAULT CURRENT DATE,
    CONSTRAINT pk_vanity_van PRIMARY KEY (van_id)
);

------------------------------------------------------------
-- TABLE: category
------------------------------------------------------------
CREATE TABLE category (
    category_id INTEGER NOT NULL,
    name VARCHAR(25) NOT NULL,
    last_update DATE NOT NULL,
    CONSTRAINT pk_category PRIMARY KEY (category_id)
);

CREATE SEQUENCE category_sequence;

CREATE OR REPLACE TRIGGER category_before_insert
BEFORE INSERT ON category
REFERENCING NEW AS NEW
FOR EACH ROW
BEGIN ATOMIC
    IF NEW.category_id IS NULL THEN
        SET NEW.category_id = NEXT VALUE FOR category_sequence;
    END IF;
    SET NEW.last_update = CURRENT DATE;
END;

CREATE OR REPLACE TRIGGER category_before_update
BEFORE UPDATE ON category
REFERENCING NEW AS NEW
FOR EACH ROW
BEGIN ATOMIC
    SET NEW.last_update = CURRENT DATE;
END;

------------------------------------------------------------
-- TABLE: film
------------------------------------------------------------
CREATE TABLE film (
    film_id INTEGER NOT NULL,
    title VARCHAR(255) NOT NULL,
    description CLOB,
    release_year VARCHAR(4),
    language_id INTEGER NOT NULL,
    original_language_id INTEGER,
    rental_duration SMALLINT DEFAULT 3 NOT NULL,
    rental_rate DECIMAL(4,2) DEFAULT 4.99 NOT NULL,
    length SMALLINT,
    replacement_cost DECIMAL(5,2) DEFAULT 19.99 NOT NULL,
    rating VARCHAR(10) DEFAULT 'G',
    special_features VARCHAR(100),
    last_update DATE DEFAULT CURRENT DATE,
    prequel_film_id INTEGER,
    CONSTRAINT pk_film PRIMARY KEY (film_id),
    CONSTRAINT fk_film_language FOREIGN KEY (language_id)
        REFERENCES language(language_id),
    CONSTRAINT fk_film_language_original FOREIGN KEY (original_language_id)
        REFERENCES language(language_id),
    CONSTRAINT chk_film_rating CHECK (rating IN ('G','PG','PG-13','R','NC-17'))
);

CREATE SEQUENCE film_sequence
    START WITH 6
    INCREMENT BY 1;

------------------------------------------------------------
-- STORED PROCEDURE: GetMovieRentalRateProc
------------------------------------------------------------
CREATE OR REPLACE PROCEDURE GetMovieRentalRateProc (
    IN movieTitle VARCHAR(255),
    OUT p_rental_rate INTEGER
)
LANGUAGE SQL
BEGIN
    IF movieTitle IS NULL THEN
        SIGNAL SQLSTATE '75001'
            SET MESSAGE_TEXT = 'Movie title cannot be null';
    END IF;

    SELECT rental_rate
    INTO p_rental_rate
    FROM film
    WHERE UPPER(title) = UPPER(movieTitle);

    IF p_rental_rate IS NULL THEN
        SET p_rental_rate = -1;
    END IF;
END;

------------------------------------------------------------
-- STORED PROCEDURE: UpdateUserProc
------------------------------------------------------------
CREATE OR REPLACE PROCEDURE UpdateUserProc (
    IN user_id INTEGER,
    OUT rows_affected INTEGER
)
LANGUAGE SQL
BEGIN
    -- Input validation
    IF user_id IS NULL THEN
        SIGNAL SQLSTATE '75002'
            SET MESSAGE_TEXT = 'User ID cannot be null';
    END IF;

    -- Update user
    UPDATE users
    SET is_active = 'N'
    WHERE auid = user_id;

    -- DB2 way to get affected rows
    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    -- User not found
    IF rows_affected = 0 THEN
        SET rows_affected = -1;
    END IF;
END;
